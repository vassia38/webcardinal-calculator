import{F as e,c as n,k as t,l as o,m as s,j as a,d as i,I as r,n as l,o as c,f,x as d,h as u,b as h,i as m,V as b,D as p,g as x}from"./p-61cc1f50.js";import{s as $,j as v,q as y,o as M,b as A,l as j,n as g,h as P,r as E,d as O,i as T,c as w}from"./p-773c47d9.js";import{c as N,d as k}from"./p-0c3518a5.js";function C(e,n,t){const o=n.getChainValue(t);if(o){for(const[n,t]of Object.entries(o))$(e,{key:n,value:t});if(!0===o._saveElement){for(const n in e)"function"==typeof e[n]&&(e[n]=e[n].bind(e));o.getElement||n.setChainValue(t,Object.assign(Object.assign({},o),{getElement:()=>e}))}}if(n.hasExpression(t)){const o=n.evaluateExpression(t);for(const[n,t]of Object.entries(o))$(e,{key:n,value:t})}}function V(e){return e.nodeType===Node.ELEMENT_NODE}function W(e){return e.nodeType===Node.TEXT_NODE&&e.nodeValue&&e.nodeValue.trim()}function I(e,t,o,s=null){if(f.includes(e.nodeName.toLowerCase()))return;if(e.nodeType!==Node.TEXT_NODE||!e.nodeValue||!e.nodeValue.trim())return;const a=[...e.nodeValue.matchAll(/\{\{\s*([^\s}}]+)\s*\}\}/g)];if(!a.length)return;const r=a.map((e=>({expression:e[0],chainWithPrefix:e[1]}))).filter((({chainWithPrefix:e})=>e.startsWith(n)||e.startsWith(i))).map((e=>{let{chainWithPrefix:a}=e;const r=a.startsWith(i);let l=e.chainWithPrefix.slice(1);!r&&s&&(l=v(s,l),a=`${n}${l}`);const c=r?o:t;return Object.assign(Object.assign({},e),{chain:l,isTranslation:r,isModel:!r,isModelExpression:c.hasExpression(l),evaluateModelExpression:()=>c.evaluateExpression(l),model:c,getChainValue:()=>{let e=c.getChainValue(l);if(r&&void 0===e){const{pathname:n}=window.location,t=d();console.warn(`No translations found for skin "${t}", page "${n}" and chain "${l}"`),e=l}return e}})}));if(!r.length)return;const l=e.nodeValue,c=()=>{let n=l;r.forEach((({expression:e,getChainValue:t,isModelExpression:o,evaluateModelExpression:s})=>{let a=t();["number","boolean"].includes(typeof a)&&(a=a.toString()),!a&&o&&(a=o?s():""),n=n.replace(e,a||"")})),e.nodeValue=n};c(),r.filter((e=>e.isModel)).forEach((({model:n,chain:t,isModelExpression:o})=>{const s=()=>{c()};if(n.onChange(t,s),j(e,t,s),o){const o=()=>{c()};n.onChangeExpressionChain(t,o),g(e,t,o)}}))}const q={bindElement:(d,$={model:null,translationModel:null})=>{const{model:B,translationModel:D,chainPrefix:F,enableTranslations:S=!1,recursive:U=!1}=$;if(B){if(W(d))I(d,B,D,F);else if(V(d)){const z=d;if(f.includes(z.tagName.toLowerCase()))return A(z,B,n,F);if(z.hasAttribute(u)){let e;z.hasAttribute(h)&&(e=z.getAttribute(h),(null==e?void 0:e.startsWith(n))&&(e=e.slice(1)));const t=v(F,e);z[m]=()=>B.hasExpression(t)?B.evaluateExpression(t):B.toObject(t)}const G=T(z,r),H=T(z,e);if(G&&H)console.error("Cannot use both data-if and data-for attributes on the same element",z);else if(G)!function(e,t,{model:o,translationModel:s,chainPrefix:a,enableTranslations:f=!1}={model:null,translationModel:null}){let d=e.getAttribute(r);if(!d.startsWith(n))return void console.warn(`Attribute "${r}" doesn't start with the chain prefix!`);d=d.slice(1);const u=v(a,d),h=Array.from(e.children);let m,b=O(h,l);const p=O(h,c);b.length||p.length||(b=Array.from(e.childNodes)),P(e,o);const x=async n=>{let i;if(n instanceof Promise)try{i=await n}catch(e){console.error("data-if condition promise failed",e),i=!1}else i=!!n;const r=m!==i;m=i,r&&(()=>{const n=m?b:p;P(e,o),n.forEach((n=>{const i=n.cloneNode(!0);E(i),e.appendChild(i),t(i,{model:o,translationModel:s,chainPrefix:a,enableTranslations:f,recursive:!0})}))})()};if(x(o.getChainValue(u)),A(e,o,n,a),f&&A(e,s,i,a),o.hasExpression(u)){x(o.evaluateExpression(u));const n=()=>{x(o.evaluateExpression(u))};o.onChangeExpressionChain(u,n),g(e,u,n)}else{const n=()=>{x(o.getChainValue(u))};o.onChange(u,n),j(e,u,n)}}(z,q.bindElement,$);else if(H)!function(r,l,{model:c,translationModel:f,chainPrefix:d,enableTranslations:u=!1}={model:null,translationModel:null}){let h=r.getAttribute(e);if(!h.startsWith(n))return void console.warn(`Attribute "${e}" doesn't start with the chain prefix!`);h=h.slice(1);const m=v(d,h);let b=c.getChainValue(m);if(!Array.isArray(b))return void console.error(`Attribute "${e}" (${h}) must be a chain to an array in the model!`,r);let p=b.length;const x=(r.getAttribute(t)||"").split(" ").filter(String),$=x.includes(o);let O=x.includes(s);const T=[],w=[];for(y(r,m);r.childNodes.length>0;){const e=r.childNodes[0];V(e)&&e.getAttribute("slot")===a?T.push(e):w.push(e),M(e,c),e.remove()}let C=[];const W=()=>{if(!p)return P(r,c),void T.forEach((e=>{const n=e.cloneNode(!0);E(n),r.appendChild(n),l(n,{model:c,translationModel:f,chainPrefix:d,enableTranslations:u,recursive:!0})}));if(O){const e=document.createElement(r.tagName),n=Array.prototype.slice.call(r.attributes);let o;for(;o=n.pop();)o.nodeName!==t&&e.setAttribute(o.nodeName,o.nodeValue);x.length>0&&e.setAttribute(t,x.join(" ")),r.insertAdjacentElement("afterend",e),r.remove(),r=e}b.forEach(((e,n)=>{const t=[];w.forEach((e=>{const o=e.cloneNode(!0),s=v(m,n);l(o,{model:c,translationModel:f,chainPrefix:s,enableTranslations:u,recursive:!0}),t.push(o)})),C[n]?t.forEach(((e,t)=>{document.createElement("div").appendChild(C[n][t].cloneNode(!0));const o=N(e),s=N(C[n][t]);k(o,s,C[n][t])})):(t.forEach((e=>{r.appendChild(e)})),C[n]=t)}));for(let e=p;e<C.length;e++)C[e].forEach((e=>{P(e,c),e.remove()}));C.splice(p)},I=(n,t=!1)=>{Array.isArray(n)||(console.error(`Attribute "${e}" must be an array in the model!`),n=[]);const o=p!==(n=n||[]).length;b=n,p=b.length,$?W():(t||o)&&(P(r,c),C=[],W())};W(),A(r,c,n,d),u&&A(r,f,i,d);const q=({targetChain:e})=>{const n=m===e;I(c.getChainValue(m),n)};if(c.onChange(m,q),j(r,m,q),c.hasExpression(m)){const e=()=>{I(c.evaluateExpression(m))};c.onChangeExpressionChain(m,e),g(r,m,e)}}(z,q.bindElement,$);else{const e=z.hasAttribute(b),t=z.hasAttribute(h);if(!z.hasAttribute(p)){if(e||t){let o;if(e?o=z.getAttribute(b):(console.warn(`Attribute "${h}" is deprecated for binding! Use the "${b}" key attribute instead.`,z),o=z.getAttribute(h)),o.startsWith(n)){o=o.slice(1);const e=v(F,o);z.setAttribute(b,`${n}${e}`),t&&z.setAttribute(h,`${n}${e}`),C(z,B,e),w(z,B,e);const s=()=>C(z,B,e);if(B.onChange(e,s),j(z,o,s),B.hasExpression(e)){const n=()=>C(z,B,e);B.onChangeExpressionChain(e,n),g(z,e,n)}}else console.warn(`Invalid chain found! (chain: "${o}")!\n`,`A valid chain must start with "${n}".\n`,"target element:",z)}z.tagName.startsWith(x.toUpperCase())||A(z,B,n,F),S&&A(z,D,i,F),Array.from(z.childNodes).filter(W).forEach((e=>{I(e,B,D,F)}))}U&&Array.from(z.children).forEach((e=>{q.bindElement(e,$)}))}}}else{const e=V(d)?d.tagName.toLowerCase():"text node";console.warn(`No model found for: ${e}!`)}},bindChildNodes:(e,n)=>{Array.from(e.childNodes).forEach((e=>{q.bindElement(e,Object.assign({},n))}))}};export{q as B}